<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Office On Fire</title>
  <link rel="icon" type="image/gif" href="/assets/fire.gif">
  <link rel="stylesheet" href="style.css">
  <link href="https://fonts.googleapis.com/css2?family=Pixelify+Sans:wght@400;700&display=swap" rel="stylesheet"> <!-- Pixelify Sans from Google Fonts -->
</head>
<body>
  <div id="hud">Arrow keys (move), 'c' (pick up item), 'v' (use item)</div>

  <div id="start-screen">
    <h1>Office On Fire</h1>
    <button id="start-button">Start Game</button>
  </div>

  <div id="building">
    <canvas id="game" width="600" height="600" style="display:none;"></canvas>
    <div id="tower"></div>
  </div>

  <div class="bird-container bird-container-one">
    <div class="bird bird-one"></div>
  </div>        
  <div class="bird-container bird-container-two">
    <div class="bird bird-two"></div>
  </div>  
  <div class="bird-container bird-container-three">
    <div class="bird bird-three"></div>
  </div> 
  <div class="bird-container bird-container-four">
    <div class="bird bird-four"></div>
  </div>
<div id="clouds">
	<div class="cloud x1"></div>
	<div class="cloud x2"></div>
	<div class="cloud x3"></div>
	<div class="cloud x4"></div>
	<div class="cloud x5"></div>
</div>

  <div id="gameover-screen" style="display:none;">
    <h1>Game Over</h1>
    <button id="restart-button">Restart</button>
  </div>

  <script type="module">
    import initModule from "./build/OfficeOnFire.js";
    import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

    async function getSupabaseConfig() {
        const res = await fetch('/getSupabaseSecrets');
        const data = await res.json();
        return data; // { url, anonKey }
    }

    // --- Supabase config ---
    const { url, anonKey } = await getSupabaseConfig();
    // local development
    // const url = "<SUPABASE_URL>";
    // const anonKey = "<SUPABASE_ANONKEY>";

    const supabase = createClient(url, anonKey);

    // assets
    const fireExtinguisherImg = new Image();
    fireExtinguisherImg.src = "/assets/fire_extinguisher.png";
    const fireImg = new Image();
    fireImg.src = "/assets/fire_256.png";
    const ghostImg = new Image();
    ghostImg.src = "/assets/ghost_512.png";
    const brickImg = new Image();
    brickImg.src = "/assets/brick.png";
    const selfImg = new Image();
    selfImg.src = "/assets/self_1024.png";
    const otherImg = new Image();
    otherImg.src = "/assets/other.png";

    const startScreen = document.getElementById("start-screen");
    const gameCanvas = document.getElementById("game");
    const gameoverScreen = document.getElementById("gameover-screen");
    const startButton = document.getElementById("start-button");
    const restartButton = document.getElementById("restart-button");
    let currentItem = null;
    let itemIcon = document.getElementById("item-icon")
    let gameState = "start"

    startButton.onclick = () => {
      gameState = "playing";
      startScreen.style.display = "none";
      gameCanvas.style.display = "block";
      //startGame(); // initialize maze, players, ghosts, etc.
    };

    restartButton.onclick = () => {
      gameState = "playing";
      gameoverScreen.style.display = "none";
      gameCanvas.style.display = "block";
      //startGame(); // reset everything
    };

    function endGame() {
      gameState = "gameover";
      gameCanvas.style.display = "none";
      gameoverScreen.style.display = "block";
    }

    // --- Identity (stable across reloads) ---
    let playerKey = localStorage.getItem("oof_player_key");
    if (!playerKey) {
      playerKey = crypto.randomUUID();
      localStorage.setItem("oof_player_key", playerKey);
    }

    // --- WASM init ---
    const Module = await initModule({
      locateFile: (p) => "./build/" + p,
    });
    console.log("WASM ready");

    // --- Presence channel ---
    const ROOM = "global";
    const channel = supabase.channel(`room-${ROOM}`, {
      config: { presence: { key: playerKey } },
    });

    // Flatten presence state: { key: [meta,...] } -> { key: meta }
    const flattenPresence = (state) => {
      const flat = {};
      for (const [k, metas] of Object.entries(state)) {
        // we always track a single meta object per client
        flat[k] = metas[0] || {};
      }
      return flat;
    };

    // Track of all players (including you)
    let players = {}; // { key: {x,y,floor} }
    let ghosts = {}; // { key: {x,y,floor} }

    // --- Canvas render ---
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const tile = 30, ox = 60, oy = 60;

    function worldToScreen(x, y) {
      const cameraX = Module.getX() - Math.floor(canvas.width / tile / 2);
      const cameraY = Module.getY() - Math.floor(canvas.height / tile / 2);
      return { sx: (x - cameraX) * tile, sy: (y - cameraY) * tile };
    }

    function drawHealthBar(ctx, sx, sy, health, maxHealth) {
      const w = tile, h = 4;
      const pct = Math.max(0, Math.min(1, health / maxHealth));
      const bx = sx, by = sy - h - 14;

      // bg
      ctx.fillStyle = "rgba(0,0,0,0.4)";
      ctx.fillRect(bx, by, w, h);

      // fill
      ctx.fillStyle = "green";
      ctx.fillRect(bx, by, w * pct, h);
    }

    function updateItemSlot(){
      const itemIcon = document.getElementById("item-icon");

      if (currentItem === "fire_extinguisher"){
        itemIcon.src = "/assets/fire_extinguisher_64.png";
        itemIcon.style.display = "block";
      } else if (currentItem === "flashlight"){
        itemIcon.src = "/assets/flashlight_64.png";
        itemIcon.style.display = "block";
      } else {
        itemIcon.style.display = "none"; // empty slot
      }
    }

    function drawSprite(img, sx, sy, sw, sh, dx, dy, dw, dh) {
      ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);
    }

    function drawFireWall(x, y, ox, oy, frameCount) {
      const spriteW = 256, spriteH = 256;

      // animation frame
      const frame = frameCount % 8;
      const sx = frame * spriteW;
      const sy = 0;

      // scale factor, e.g., 1.5x or 2x
      const scale = 2; 
      const dw = tile * scale;
      const dh = tile * scale;

      // center the bigger fire on the tile
      const dx = ox + x * tile - (dw - tile)/2;
      const dy = oy + y * tile - (dh - tile)/2;

      drawSprite(fireImg, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
    }

    function drawBrickWall(x, y, ox, oy) {
      const spriteW = 32, spriteH = 32;

      // animation frame
      const sx = 0;
      const sy = 0;

      // scale factor, e.g., 1.5x or 2x
      const scale = 1;
      const dw = tile * scale;
      const dh = tile * scale;

      // center the bigger fire on the tile
      const dx = ox + x * tile - (dw - tile)/2;
      const dy = oy + y * tile - (dh - tile)/2;

      drawSprite(brickImg, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
    }

    function drawItem(x, y, ox, oy) {
      const spriteW = 64, spriteH = 64;

      // animation frame
      const sx = 0;
      const sy = 0;

      // scale factor, e.g., 1.5x or 2x
      const scale = 2;
      const dw = tile * scale;
      const dh = tile * scale;

      // center the bigger fire on the tile
      const dx = ox + x * tile - (dw - tile)/2;
      const dy = oy + y * tile - (dh - tile)/2;

      drawSprite(fireExtinguisherImg, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
    }

    function drawGhost(x, y, ox, oy, direction, update) {
      const frameCols = 4; // frames per row
      const frameRows = 4; // directions
      const spriteW = 512;
      const spriteH = 512;

      const row = direction; // direction: "N": 0, "E": 1, "S": 2, "W": 3

      const sx = ghostFrameCount % frameCols * spriteW;
      if (update){
        ghostFrameCount = (ghostFrameCount + 1)%frameCols;
      }
      const sy = row * spriteH;

      const scale = 2*tile / spriteW;
      const dw = spriteW * scale;
      const dh = spriteH * scale;

      // center on tile
      const dx = ox + x * tile - (dw - tile)/2;
      const dy = oy + y * tile - (dh - tile)/2;

      drawSprite(ghostImg, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
    }

    function drawSelf(x, y, ox, oy, direction, update) {
      const frameCols = 4; // frames per row
      const frameRows = 4; // directions
      const spriteW = 1024;
      const spriteH = 1024;

      const row = direction; // direction: "N": 0, "E": 1, "S": 2, "W": 3

      const sx = selfFrameCount % frameCols * spriteW;
      if (update){
        selfFrameCount = (selfFrameCount + 1)%frameCols;
      }
      const sy = row * spriteH;

      const scale = 2*tile / spriteW;
      const dw = spriteW * scale;
      const dh = spriteH * scale;

      // center on tile
      const dx = ox + x * tile - (dw - tile)/2;
      const dy = oy + y * tile - (dh - tile)/2;

      drawSprite(selfImg, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
    }

    function drawOther(x, y, ox, oy, direction, update, frame) {
      const frameCols = 4; // frames per row
      const frameRows = 4; // directions
      const spriteW = 16;
      const spriteH = 16;

      const row = direction; // direction: "N": 0, "E": 1, "S": 2, "W": 3

      const sx = frame % frameCols * spriteW;
      const sy = row * spriteH;

      const scale = 2*tile / spriteW;
      const dw = spriteW * scale;
      const dh = spriteH * scale;

      // center on tile
      const dx = ox + x * tile - (dw - tile)/2;
      const dy = oy + y * tile - (dh - tile)/2;

      drawSprite(otherImg, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
    }

    let frameCount = 0;
    let ghostFrameCount = 0;
    let selfFrameCount = 0;

    function render(updateEnvironment) {
      if (gameState !== "playing") return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      let offsetX = canvas.width / 2 - Module.getX() * tile;
      let offsetY = canvas.height / 2 - Module.getY() * tile;
      let mazeHeight = Module.getHeight();
      let mazeWidth = Module.getWidth();

      // draw maze
      for (let x = 0; x < mazeHeight; x++) {
        for (let y = 0; y < mazeWidth; y++) {
          if (Module.getCell(x, y) === 'F') { // fire
            drawFireWall(x, y, offsetX, offsetY, frameCount);
          }
          if (Module.getCell(x, y) == '#'){ // boundary obstacles
            drawBrickWall(x, y, offsetX, offsetY);
          }
          if (Module.getCell(x, y) === 'E') { // exit
            ctx.fillStyle = "green";
            ctx.fillRect(offsetX + x*tile, offsetY + y*tile, tile, tile);
          }
          if (Module.getCell(x, y) === 'I') { // item
            drawItem(x, y, offsetX, offsetY);
          }
          if (Module.getCell(x, y) === 'T'){ // temporary fire
            ctx.fillStyle = "#7D0B0B";
            ctx.fillRect(offsetX + x*tile, offsetY + y*tile, tile, tile);
          }
        }
      }
      if (updateEnvironment){
        frameCount++;
      }

      // draw ghosts
      for (const [key, g] of Object.entries(ghosts)) {
        if (ghosts[key].floor !== Module.getFloor()){
          // don't draw, not on the same floor
        } else {
          drawGhost(g.x, g.y, offsetX, offsetY, Module.ghostGetDirection(), updateEnvironment)
        }
      }

      // draw grid (optional)
      // ctx.globalAlpha = 0.2;
      // for (let i = 0; i < 30; i++) {
      //   ctx.fillRect(ox + i*tile, oy, 1, 300);
      //   ctx.fillRect(ox, oy + i*tile, 300, 1);
      // }
      // ctx.globalAlpha = 1;

      // draw players
      for (const [key, p] of Object.entries(players)) {
        ctx.fillStyle = key === playerKey ? "red" : "blue";
        if (key !== playerKey && players[key].floor !== Module.getFloor()){
          // don't draw, not on the same floor
        } else if (key === playerKey){ // self
          drawSelf(p.x, p.y, offsetX, offsetY, Module.getDirection(), updateEnvironment)
          const { sx, sy } = worldToScreen(p.x, p.y);
          drawHealthBar(ctx, sx, sy, p.health ?? 100, 100);
          if (p.health <= 0){ endGame(); }
        } else {
          drawOther(p.x, p.y, offsetX, offsetY, p.direction, updateEnvironment, Math.floor(Math.random() * 4));
          const { sx, sy } = worldToScreen(p.x, p.y);
          drawHealthBar(ctx, sx, sy, p.health ?? 100, 100);
        }
      }

      // item slot
      const slotX = 10;
      const slotY = 10;
      const slotSize = 40;

      // draw slot box
      ctx.fillStyle = "white";
      ctx.fillRect(slotX, slotY, slotSize, slotSize);
      ctx.strokeStyle = "black";
      ctx.lineWidth = 2;
      ctx.strokeRect(slotX, slotY, slotSize, slotSize);
      // draw icon if player has item
      if (currentItem === "fire_extinguisher") {
        ctx.drawImage(fireExtinguisherImg, slotX + 4, slotY + 4, slotSize - 8, slotSize - 8);
      }

      ctx.font = "24px 'Pixelify Sans'";
      ctx.fillStyle = "white";
      ctx.textAlign = "right"; // align text to the right

      // draw text at top-right corner
      ctx.fillText("Level: " + Module.getFloor(), canvas.width - 10, 30);
    }

    // --- Presence event handlers ---
    channel
      .on("presence", { event: "sync" }, () => {
        players = flattenPresence(channel.presenceState());
        render(false);
      })
      .on("broadcast", { event: "item_picked" }, ({ payload }) => {
        const { messageType, x, y, floor, ghost_id } = payload;
        console.log("received broadcast (item_picked)", payload);
        Module.addMessage(messageType, x, y, floor, ghost_id);
        render(false);
      })
      .on("broadcast", { event: "fire_extinguished" }, ({ payload }) => {
        const { messageType, x, y, floor, ghost_id } = payload;
        console.log("received broadcast (fire_extinguished)", payload);
        Module.addMessage(messageType, x, y, floor, ghost_id);
        render(false);
      })
      .on("broadcast", { event: "ghost_moved" }, ({ payload }) => { // update ghosts that are not owned by this client
        const { ghostId, x, y, floor } = payload;
        console.log("received broadcast (ghost)", payload);
        ghosts[ghostId] = { x: x, y: y, floor: floor };
        render(false);
      })
      // (Optional) keep logs muted; movement updates often show as join/leave diffs internally.
      // .on("presence", { event: "join" }, ({ key }) => console.log("join", key))
      // .on("presence", { event: "leave" }, ({ key }) => console.log("leave", key))
      .subscribe(async (status) => {
        if (status !== "SUBSCRIBED") return;
        // Initial presence payload (your current position from C++)
        channel.track({
          x: Module.getX(),
          y: Module.getY(),
          floor: Module.getFloor(),
          health: Module.getHealth(),
          direction: 0
        });
      });

    // --- Movement -> update local + track() presence ---
    window.addEventListener("keydown", (e) => {
      if (gameState !== "playing") return;

      if (e.key === "ArrowUp" || e.key === "ArrowDown" || e.key === "ArrowLeft" || e.key === "ArrowRight"){ // movement
        let dx = 0, dy = 0;
        if (e.key === "ArrowUp"){
          dy = -1;
          Module.setDirection(3);
        }
        if (e.key === "ArrowDown"){
          dy = 1;
          Module.setDirection(2);
        }
        if (e.key === "ArrowLeft"){
          dx = -1;
          Module.setDirection(1);
        }
        if (e.key === "ArrowRight"){
          dx = 1;
          Module.setDirection(0);
        }
        if (!dx && !dy) return;

        Module.movePlayer(dx, dy);
      } else if (e.key === "c"){ // pick up item
        
        const x = Module.getX();
        const y = Module.getY();
        const floor = Module.getFloor();

        console.log("tried to pick up", x, y, floor);

        if (Module.tryPickup(x, y, floor)) {
          // picked locally → broadcast to others
          console.log("picked up")
          currentItem = "fire_extinguisher";
          channel.send({
            type: "broadcast",
            event: "item_picked",
            payload: { 
              messageType: 0, x, y, floor, ghost_id: 0 
            }
          });
        }
      } else if (e.key === "v"){
        if (currentItem){
          console.log("Used item:", currentItem);
          const x = Module.getX();
          const y = Module.getY();
          const floor = Module.getFloor();
          const res = Module.tryUse(floor);
          console.log(res)
          if (res[0]){ // item actually has some use
            console.log("actually used")
            channel.send({
              type: "broadcast",
              event: "fire_extinguished",
              payload: { 
                messageType: 2, x: res[1][0], y: res[1][1], floor, ghost_id: 0 
              }
            });
          }
          // TODO Apply effect here (e.g. heal, extinguish, etc.)
          currentItem = null;
        }

      }

      // Update my local cached presence immediately for snappy rendering
      players[playerKey] = {
        x: Module.getX(),
        y: Module.getY(),
        floor: Module.getFloor(),
        health: Module.getHealth(),
        direction: Module.getDirection()
      };
      render(false);

      // Send new state to others (this does NOT re-subscribe; it's the correct way to update presence)
      channel.track(players[playerKey]);
    });

    setInterval(() => {
      if (gameState !== "playing") return;
      render(true);
    }, 100);

    setInterval(() => {
        if (gameState !== "playing") return;
        Module.tick();
        // get player positions, call moveGhost, broadcast
        const playerCoords = new Module.VectorPairIntInt();

        for (const [key, p] of Object.entries(players)) {
          if (players[key].floor !== Module.getFloor()){
            // don't draw, not on the same floor
          } else {
            playerCoords.push_back([p.x, p.y]);
          }
        }

        const newGhostPos = Module.moveGhost(playerCoords);
        //console.log("newGhostPos", newGhostPos);
        channel.send({
          type: "broadcast",
          event: "ghost_moved",
          payload: { ghostId: playerKey, x: newGhostPos[0], y: newGhostPos[1], floor: Module.getFloor() }
        });
        // update local ghosts cache
        ghosts[playerKey] = {
          x: newGhostPos[0],
          y: newGhostPos[1],
          floor: Module.getFloor(),
        };

        if (playerKey in players && newGhostPos[0] === players[playerKey].x && newGhostPos[1] === players[playerKey].y){
          Module.takeDamage(30);
          players[playerKey].health = Module.getHealth(); // instant update since local
        }
    }, 1000);

    // Render once (in case presence sync hasn't arrived yet)
    players[playerKey] = { x: Module.getX(), y: Module.getY(), floor: Module.getFloor(), health: Module.getHealth(), direction: Module.getDirection() };
    render(false);
  </script>
</body>
</html>