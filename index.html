<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Office On Fire</title>
  <link rel="icon" type="image/gif" href="/assets/fire.gif">
  <link rel="stylesheet" href="style.css">
  <link href="https://fonts.googleapis.com/css2?family=Pixelify+Sans:wght@400;700&display=swap" rel="stylesheet"> <!-- Pixelify Sans from Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@900&display=swap" rel="stylesheet"> <!-- Montserrat Black -->
</head>
<body>
  <div id="hud">Arrow keys (move), 'c' (pick up item), 'v' (use item)</div>
<!-- 
  <div id="start-screen">
    <h1>Office On Fire</h1>
    <button id="start-button">Start Game</button>
  </div>
 -->
  <div id="building">
    <div class="canvas-wrapper" style="position: relative; width: 600px; height: 600px;">
      <canvas id="game" width="600" height="600" style="position:absolute;top: 0; left: 0;z-index:0;"></canvas>
      <canvas id="blood" width="600" height="600" style="position:absolute;top: 0; left: 0;z-index:1;"></canvas>
      <canvas id="shadow" width="600" height="600" style="position:absolute;top: 0; left: 0;z-index:2;"></canvas>
      <input
        type="text"
        id="roomInput"
        placeholder="Enter room number + <enter>"
        style="
          position: absolute;
          top: 500px;
          left: 150px;
          width: 300px;
          font-size: 20px;
          font-family: 'Pixelify Sans', sans-serif;
          padding: 5px;
          text-align: center;
          z-index: 10;
        "
      />
      <div id="gameover-screen" style="display:none;">
        <h1 style="font-family: 'Pixelify Sans', sans-serif;">Game Over</h1>
        <div style="display:flex; justify-content:center; align-items:center; height:64px;">
          <img src="/assets/flaming_skull.png" alt="" style="width:64px; height:64px;">
        </div>
        <p id="final-level" style="font-family: 'Pixelify Sans', sans-serif; font-size: 18px;"></p>
        <button id="restart-button" style="font-family: 'Pixelify Sans', sans-serif;">Restart</button>
      </div>
    </div>
    <div id="tower"></div>
  </div>

  <div class="bird-container bird-container-one">
    <div class="bird bird-one"></div>
  </div>        
  <div class="bird-container bird-container-two">
    <div class="bird bird-two"></div>
  </div>  
  <div class="bird-container bird-container-three">
    <div class="bird bird-three"></div>
  </div> 
  <div class="bird-container bird-container-four">
    <div class="bird bird-four"></div>
  </div>
<div id="clouds">
	<div class="cloud x1"></div>
	<div class="cloud x2"></div>
	<div class="cloud x3"></div>
	<div class="cloud x4"></div>
	<div class="cloud x5"></div>
</div>

<script>
// script for setting up the tower
const tower = document.getElementById("tower");

const towerHeight = 1000;
const towerWidthTop = 600;
const towerWidthBottom = towerWidthTop * 0.8;
const windowRows = 20;
const windowsPerRow = 6;
const tan_theta = (towerWidthTop - towerWidthBottom)/2/towerHeight;

const windowBaseWidth = 40;
const windowHeight = 25;

for (let row = 0; row < windowRows; row++) {
    const y = (row / windowRows) * towerHeight + 20;
    const rowRatio = y / towerHeight;

    const towerRowWidth = towerWidthTop - (towerWidthTop - towerWidthBottom) * (y / towerHeight);
    const xOffset = (towerWidthTop - towerRowWidth) / 2;

    for (let col = 0; col < windowsPerRow; col++) {
        const win = document.createElement('div');
        win.className = 'window';

        const spacing = towerRowWidth / (windowsPerRow + 1);
        const centerX = xOffset + spacing * (col + 1);

        const winMidWidth = windowBaseWidth*(towerRowWidth/towerWidthTop);
        const winTopWidth = winMidWidth + (windowHeight/towerHeight)*tan_theta;
        const winBottomWidth = winMidWidth - (windowHeight/towerHeight)*tan_theta;

        const left = centerX - winTopWidth / 2;
        win.style.left = `${left}px`;
        win.style.top = `${y}px`;
        win.style.width = `${winTopWidth}px`;
        win.style.height = `${windowHeight}px`;

        const bottomInset = (winTopWidth - winBottomWidth) / 2;
        const bottomLeft = (bottomInset / winTopWidth) * 100;
        const bottomRight = 100 - bottomLeft;

        win.style.clipPath = `polygon(
            0% 0%,            /* top-left */
            100% 0%,          /* top-right */
            ${bottomRight}% 100%, /* bottom-right */
            ${bottomLeft}% 100%   /* bottom-left */
        )`;

        tower.appendChild(win);
    }
}

function igniteRandomWindow() {
    const windows = document.querySelectorAll('.window');
    const fireCount = Math.floor(Math.random() * 10) + 1;

    for (let i = 0; i < fireCount; i++) {
        const win = windows[Math.floor(Math.random() * windows.length)];

        if (win.querySelector('.fire')) continue; // skip if already burning

        const fire = document.createElement('div');
        fire.className = 'fire';

        // Optional: match fire size to window
        const width = parseFloat(win.style.width);
        const height = parseFloat(win.style.height);
        fire.style.width = `${width * 0.6}px`;
        fire.style.height = `${height * 0.8}px`;

        win.appendChild(fire);

        // Remove the fire after a short time
        const duration = Math.random() * 2000 + 2000;
        setTimeout(() => {
            fire.remove();
        }, duration);
    }
}

setInterval(igniteRandomWindow, 3000);
</script>

  <script type="module">
    import initModule from "./build/OfficeOnFire.js";
    import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

    async function getSupabaseConfig() {
        const res = await fetch('/getSupabaseSecrets');
        const data = await res.json();
        return data; // { url, anonKey }
    }

    // --- Supabase config ---
    const { url, anonKey } = await getSupabaseConfig();
    // local development
    // const url = "<SUPABASE_URL>";
    // const anonKey = "<SUPABASE_ANONKEY>";

    const supabase = createClient(url, anonKey);
    window.supabase = supabase;

    // assets

    const imageSources = {
      fire_extinguisher: "/assets/fire_extinguisher_1024.png",
      fire_extinguisher_s: "/assets/fire_extinguisher_1024_s.png",
      laser: "/assets/laser_1024.png",
      potion: "/assets/potion_1024.png",
      energy_cube: "/assets/energy_cube_gpt_1024.png",
      energy_cube_s: "/assets/energy_cube_gpt_1024_s.png",
      fire: "/assets/fire_256.png",
      ghost: "/assets/ghost_512.png",
      brick: "/assets/brick_gpt_1024.png",
      self: "/assets/self_1024.png",
      other: "/assets/other_1024.png",
      spark: "/assets/spark_256.png",
      ghost_inst: "/assets/ghost_1024.png",
      exit: "/assets/exit.png",
      arrow_keys: "/assets/arrowkeys.png",
      chair: "/assets/chair_dark.png",
      vending: "/assets/vending_machine_bold.png",
      table: "/assets/table_revamped.png",
      printer: "/assets/printer.png",
      water: "/assets/water_cooler_bold.png",
      bubble: "/assets/bubble_1024.png",
      bubble_s: "/assets/bubble_1024_s.png",
      exit_0: "/assets/exit-0.png",
      exit_1: "/assets/exit-1.png",
      exit_2: "/assets/exit-2.png",
      exit_3: "/assets/exit-3.png",
      wood_tile: "/assets/wood_tile_1024.png",
      stone_tile: "/assets/stone_tile_1024.png"
    }
    let images = {};
    let loadedImages = 0;
    const totalImages = Object.keys(imageSources).length;
    function loadImages(sources) {
      const promises = Object.entries(sources).map(([key, src]) => {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve([key, img]);
          img.onerror = () => reject(new Error("Failed to load " + src));
          img.src = src;
        });
      });

      return Promise.all(promises).then(entries => Object.fromEntries(entries));
    }


    // audio

    const bgMusic = new Audio('/assets/fire_sound.m4a');
    bgMusic.loop = true;
    bgMusic.volume = 0.3;
    bgMusic.pause();
    const fireExtinguisherSound = new Audio('/assets/fire_extinguisher.mp3');
    const gameOverSound = new Audio('/assets/gameover.m4a');
    const hurtSound = new Audio('/assets/hurt.m4a');
    const levelCompleteSound = new Audio('/assets/level-complete.m4a');
    const explosionSound = new Audio('/assets/explosion.m4a');
    const getItemSound = new Audio('/assets/get-item.m4a');
    function playSound(obj){ 
      if (obj === gameOverSound){ obj.volume = 0.25; }
      else { obj.volume = 0.3; }
      obj.currentTime = 0; obj.play(); 
    }

    let timeoutId = null; // store loop's timer
    let sound = null;

    function playSoundLoopWithRandomDelay(src, base=40, std=10) {
      sound = new Audio(src);
      sound.volume = 0.3;

      function playAndScheduleNext() {
        sound.currentTime = 0;
        sound.play();

        const min = base - std;
        const max = base + std;
        const randomDelay = Math.random() * (max - min) + min;

        timeoutId = setTimeout(playAndScheduleNext, randomDelay * 1000);
      }

      playAndScheduleNext(); // start the first play
    }

    function stopSoundLoop() {
      clearTimeout(timeoutId);
      if (sound){
        sound.pause();
        sound.currentTime = 0;
      }
    }

    //const startScreen = document.getElementById("start-screen");
    // const gameCanvas = document.getElementById("game");
    const gameoverScreen = document.getElementById("gameover-screen");
    //const startButton = document.getElementById("start-button");
    const restartButton = document.getElementById("restart-button");
    let currentItem = null;
    let currentItemCode = -1;
    let itemIcon = document.getElementById("item-icon")
    let gameState = "instructions"

    var items = []; // blood splatter

    // startButton.onclick = () => {
    //   gameState = "playing";
    //   bgMusic.play();
    //   stopSoundLoop();
    //   playSoundLoopWithRandomDelay("/assets/help_me.mp3", 40, 10);
    //   //startScreen.style.display = "none";
    //   gameCanvas.style.display = "block";
    //   ghostInterval(Module.get_d());
    //   players[playerKey].active = true;
    //   channel.track(players[playerKey]);
    //   //startGame(); // initialize maze, players, ghosts, etc.
    // };

    restartButton.onclick = () => {
      gameState = "playing";
      bgMusic.play();
      stopSoundLoop();
      playSoundLoopWithRandomDelay("/assets/help_me.mp3", 40, 10);
      gameoverScreen.style.display = "none";
      canvas.style.display = "block";
      Module.restart();
      players[playerKey] = { x: Module.getX(), y: Module.getY(), floor: Module.getFloor(), health: Module.getHealth(), direction: Module.getDirection(), active: (gameState === "playing"), invincible: Module.get_invincibility() };
      channel.track(players[playerKey]);
      blood_ctx.clearRect(0, 0, 600, 600);
      shadow_ctx.clearRect(0, 0, 600, 600);
      items = [];
      currentItem = null;
      currentItemCode = -1;
      //startGame(); // reset everything
    };

    function endGame() {
      bgMusic.pause();
      stopSoundLoop();
      playSound(gameOverSound);
      gameState = "gameover";
      //gameCanvas.style.display = "none";
      gameoverScreen.style.display = "block";
      players[playerKey] = {
        x: Module.getX(),
        y: Module.getY(),
        floor: Module.getFloor(),
        health: Module.getHealth(),
        direction: Module.getDirection(),
        active: false,
        invincible: Module.get_invincibility()
      };
      channel.track(players[playerKey]);

      // Update the level display text
      const levelElem = document.getElementById('final-level');
      levelElem.textContent = `Level reached: ${Module.getFloor()}`;

      // Show game over screen
      document.getElementById('gameover-screen').style.display = 'block';
    }

    // --- Identity (stable across reloads) ---
    let playerKey = localStorage.getItem("oof_player_key");
    if (!playerKey) {
      playerKey = crypto.randomUUID();
      localStorage.setItem("oof_player_key", playerKey);
    }

    // --- WASM init ---
    const Module = await initModule({
      locateFile: (p) => "./build/" + p,
    });
    console.log("WASM ready");

    // --- Presence channel ---
    const ROOM = "global";
    let channel;

    const roomInput = document.getElementById("roomInput");
    roomInput.focus();
    roomInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        const roomNumber = roomInput.value.trim();
        if (!roomNumber) return alert("Please enter a room number");

        // Hide input
        roomInput.style.display = "none";

        // Join Supabase room or do something with input
        joinRoom(roomNumber); // Your function to create/join the channel
        gameState = "transition";
        transitionStart = performance.now();
      }
    });


    function joinRoom(roomNumber) {
      if (!window.supabase) {
        alert("Supabase not initialized!");
        return;
      }

      // Clean up previous channel if needed
      if (channel) {
        channel.unsubscribe();
      }

      // Join new room channel
      channel = supabase.channel(`room-${roomNumber}`, {
        config: {
          presence: { key: playerKey }
        }
      });

    // --- Presence event handlers ---
    channel
      .on("presence", { event: "sync" }, () => {
        players = flattenPresence(channel.presenceState());
        render(false);
      })
      .on("broadcast", { event: "item_picked" }, ({ payload }) => {
        const { messageType, x, y, floor, ghost_id } = payload;
        Module.addMessage(messageType, x, y, floor, ghost_id);
        render(false);
      })
      .on("broadcast", { event: "fire_extinguished" }, ({ payload }) => {
        const { messageType, x, y, floor, ghost_id } = payload;
        playSound(fireExtinguisherSound);
        Module.addMessage(messageType, x, y, floor, ghost_id);
        render(false);
      })
      .on("broadcast", { event: "ghost_moved" }, ({ payload }) => { // update ghosts that are not owned by this client
        const { ghostId, x, y, floor } = payload;
        ghosts[ghostId] = { x: x, y: y, floor: floor, active: true }; // sender only sends if ghost active
        render(false);
      })
      .on("broadcast", { event: "illuminate" }, ({ payload }) => {
        const { ghost_id, x, y, floor } = payload;
        Module.illuminate(x, y);
        render(false);
      })
      .on("broadcast", { event: "ghost_eliminated" }, ({ payload }) => { // update ghosts that are not owned by this client
        const { ghost_id, x, y, floor } = payload;
        delete ghosts[ghost_id]; // delete the ghost that is eliminated
        render(false);
      })
      .subscribe(async (status) => {
        if (status !== "SUBSCRIBED") return;
        // Initial presence payload (your current position from C++)
        channel.track({
          x: Module.getX(),
          y: Module.getY(),
          floor: Module.getFloor(),
          health: Module.getHealth(),
          direction: 0,
          active: (gameState === "playing"),
          invincible: Module.get_invincibility()
        });
      });
    }

    // Flatten presence state: { key: [meta,...] } -> { key: meta }
    const flattenPresence = (state) => {
      const flat = {};
      for (const [k, metas] of Object.entries(state)) {
        // we always track a single meta object per client
        flat[k] = metas[0] || {};
      }
      return flat;
    };

    // Track of all players (including you)
    let players = {}; // { key: {x,y,floor} }
    let ghosts = {}; // { key: {x,y,floor} }

    // --- Canvas render ---
    function setupHiDPICanvas(canvas, width, height) {
      const dpr = window.devicePixelRatio || 1;

      // Set canvas internal resolution *higher*
      canvas.width = width * dpr;
      canvas.height = height * dpr;

      // Keep CSS size the same
      canvas.style.width = width + "px";
      canvas.style.height = height + "px";

      const ctx = canvas.getContext("2d");
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // scale drawings so coords stay logical
      return ctx;
    }

    const canvas = document.getElementById("game");
    const ctx = setupHiDPICanvas(canvas, 600, 600);

    let transitionStart = 0;
    let invincibility = false;

    function drawInstructions(now, alpha = 1) {
      ctx.save();
      ctx.globalAlpha = alpha;

      ctx.fillStyle = "#0f0f12";
      ctx.fillRect(0, 0, 600, 600);

      ctx.fillStyle = "#111318";
      ctx.fillRect(50, 50, 500, 500);

      ctx.fillStyle = "#e5e7eb";
      ctx.font = "bold 36px 'Montserrat', sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Office on Fire", 300, 100);

      ctx.font = "12px 'Montserrat', sans-serif";
      ctx.textAlign = "left";
      ctx.fillStyle = "#cbd5e1";
      ctx.drawImage(
        images.exit,
        50, // dx
        140, // dy
        64,
        64
      );
      ctx.fillText("The office is on fire...", 130, 150);
      ctx.fillText("Head to the exit as quickly as possible!", 130, 170);

      ctx.drawImage(
        images.arrow_keys,
        50, // dx
        220, // dy
        64,
        64
      );
      ctx.fillText("Arrow Keys: Move", 130, 230);
      ctx.fillText("c                   : Pick up item", 130, 250);
      ctx.fillText("v                   : Use item", 130, 270);


      ctx.drawImage(
        images.ghost_inst,
        50, // dx
        300, // dy
        64,
        64
      );
      ctx.fillText("Avoid the burning corpse!", 130, 340);

      ctx.font = "10px 'Montserrat', sans-serif";

      ctx.drawImage(
        images.fire_extinguisher,
        50, // dx
        380, // dy
        64,
        64
      );
      ctx.fillText("Puts out fire", 50, 460);

      ctx.drawImage(
        images.laser,
        160, // dx
        380, // dy
        64,
        64
      );
      ctx.fillText("Broadcast location", 145, 460);

      ctx.drawImage(
        images.potion,
        270, // dx
        380, // dy
        64,
        64
      );
      ctx.fillText("Adds HP", 280, 460);

      ctx.drawImage(
        images.energy_cube,
        380, // dx
        380, // dy
        64,
        64
      );
      ctx.fillText("Fries corpses", 375, 460);

      ctx.drawImage(
        images.bubble,
        490, // dx
        380, // dy
        64,
        64
      );
      ctx.fillText("Protects from fire", 475, 460);

      ctx.restore();
    }

    /* blood splatter section begin */

    const blood_canvas = document.getElementById("blood");
    const blood_ctx = blood_canvas.getContext("2d");
    const shadow_canvas = document.getElementById("shadow");
    const shadow_ctx = shadow_canvas.getContext("2d");
    var redtone = 'rgb(' + (130 + (Math.random() * 105 | 0)) + ',0,0)';
    shadow_ctx.fillStyle = blood_ctx.fillStyle = redtone;
    var focused = false;
    var clicked = false;

    function splat(x, y, arr, scatter) {
      for (var i = 0; i < 30; i++) {
        var s = Math.random() * Math.PI;
        var dirx = (((Math.random() < .5) ? 3 : -3) * (Math.random() * 3)) * scatter;
        var diry = (((Math.random() < .5) ? 3 : -3) * (Math.random() * 3)) * scatter;
        arr.push({
          x: x,
          y: y,
          dx: dirx, 
          dy: diry,
          size: s
        });
      }
    }

    function circle(x, y, s, c) {
      c.beginPath();
      c.arc(x, y, s * 5, 0, 2 * Math.PI, false);
      c.fill();
      c.closePath();
    }

    function drawsplat(arr, gravity, consistency) {
      var i = arr.length
      while (i--) {
        var t = arr[i];
        var x = t.x, y = t.y, s = t.size;
        circle(x, y, s, blood_ctx); // temporary animation

        t.dy -= gravity; 
        t.x -= t.dx;
        t.y -= t.dy;
        t.size -= 0.05;

        if (arr[i].size < 0.3 || Math.random() < consistency) {
            circle(x, y, s, shadow_ctx); // persistent animation
            arr.splice(i, 1);
        }
      }
      blood_ctx.drawImage(shadow_canvas, 0, 0);  
    }

    function drawloop() {
      if (focused) { requestAnimationFrame(drawloop); }
      blood_ctx.clearRect(0, 0, blood_canvas.width, blood_canvas.height);
      drawsplat(items, 0.2, 0.04);
    }

    /* blood splatter section end */

    const tile = 30, ox = 60, oy = 60;

    function worldToScreen(x, y) {
      const cameraX = Module.getX() - Math.floor(canvas.clientWidth / tile / 2);
      const cameraY = Module.getY() - Math.floor(canvas.clientHeight / tile / 2);
      return { sx: (x - cameraX) * tile, sy: (y - cameraY) * tile };
    }

    ctx.imageSmoothingEnabled = false;

    function drawHealthBar(ctx, sx, sy, health, maxHealth) {
      const w = tile, h = 4;
      const pct = Math.max(0, Math.min(1, health / maxHealth));
      const bx = sx, by = sy - h - 14;

      // bg
      ctx.fillStyle = "rgba(0,0,0,0.4)";
      ctx.fillRect(bx, by, w, h);

      // fill
      ctx.fillStyle = "green";
      ctx.fillRect(bx, by, w * pct, h);
    }

    function drawSprite(img, sx, sy, sw, sh, dx, dy, dw, dh) {
      ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);
    }

    function drawFireWall(x, y, ox, oy, frameCount) {
      const spriteW = 256, spriteH = 256;

      // animation frame
      const frame = frameCount % 8;
      const sx = frame * spriteW;
      const sy = 0;

      // scale factor, e.g., 1.5x or 2x
      const scale = 2; 
      const dw = tile * scale;
      const dh = tile * scale;

      // center the bigger fire on the tile
      const dx = ox + x * tile - (dw - tile)/2;
      const dy = oy + y * tile - (dh - tile)/2;

      drawSprite(images.fire, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
    }

    function drawItemS(item_id, x, y, ox, oy, frameCount) {
      const spriteW = 256, spriteH = 256;

      // animation frame
      const frame = frameCount % 4;
      const sx = frame * spriteW;
      const sy = 0;

      // scale factor, e.g., 1.5x or 2x
      const scale = 2; 
      const dw = tile * scale;
      const dh = tile * scale;

      // center the bigger fire on the tile
      const dx = ox + x * tile - (dw - tile)/2;
      const dy = oy + y * tile - (dh - tile)/2;

      if (item_id === 0){
        drawSprite(images.fire_extinguisher_s, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
      } else if (item_id === 1){
        // TODO laser
      } else if (item_id === 2){
        drawSprite(images.energy_cube_s, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
      } else if (item_id === 3){
        // TODO potion
      } else if (item_id === 4){
        drawSprite(images.bubble_s, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
      }
    }


    function drawSpark(x, y, ox, oy, frameCount) {
      const spriteW = 256, spriteH = 256;

      // animation frame
      const frame = frameCount % 9;
      const sx = frame * spriteW;
      const sy = 0;

      // scale factor, e.g., 1.5x or 2x
      const scale = 2; 
      const dw = tile * scale;
      const dh = tile * scale;

      // center the bigger fire on the tile
      const dx = ox + x * tile - (dw - tile)/2;
      const dy = oy + y * tile - (dh - tile)/2;

      drawSprite(images.spark, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
    }

    function drawFloor(x, y, ox, oy, sprite_id) {
      const spriteW = 1024, spriteH = 1024;

      // animation frame
      const sx = 0;
      const sy = 0;

      // scale factor, e.g., 1.5x or 2x
      const scale = 1;
      const dw = tile * scale;
      const dh = tile * scale;

      // center the bigger fire on the tile
      const dx = ox + x * tile - (dw - tile)/2;
      const dy = oy + y * tile - (dh - tile)/2;
      if (sprite_id === 0){
        drawSprite(images.stone_tile, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
      } else if (sprite_id === 1){
        drawSprite(images.wood_tile, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
      } else if (sprite_id === 2){
        drawSprite(images.brick, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
      } else if (sprite_id === 3){
        drawSprite(images.exit_0, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
      } else if (sprite_id === 4){
        drawSprite(images.exit_1, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
      } else if (sprite_id === 5){
        drawSprite(images.exit_2, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
      } else if (sprite_id === 6){
        drawSprite(images.exit_3, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
      }
    }

    function drawOffice(item_id, x, y, ox, oy) {
      const spriteW = 1024, spriteH = 1024;

      // animation frame
      const sx = 0;
      const sy = 0;

      // scale factor, e.g., 1.5x or 2x
      const scale = 2;
      const dw = tile * scale;
      const dh = tile * scale;

      // center the bigger fire on the tile
      const dx = ox + x * tile - (dw - tile)/2;
      const dy = oy + y * tile - (dh - tile)/2;
      if (item_id == 0){
        drawSprite(images.chair, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
      } else if (item_id == 1){
        drawSprite(images.table, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
      } else if (item_id == 2){
        drawSprite(images.water, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
      } else if (item_id == 3){
        drawSprite(images.vending, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
      } else if (item_id == 4){
        drawSprite(images.water, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
      }
    }

    function drawItem(item_id, x, y, ox, oy) {
      const spriteW = 1024, spriteH = 1024;

      // animation frame
      const sx = 0;
      const sy = 0;

      // scale factor, e.g., 1.5x or 2x
      const scale = 2;
      const dw = tile * scale;
      const dh = tile * scale;

      // center the bigger fire on the tile
      const dx = ox + x * tile - (dw - tile)/2;
      const dy = oy + y * tile - (dh - tile)/2;
      if (item_id == 0){
        drawSprite(images.fire_extinguisher, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
      } else if (item_id == 1){
        drawSprite(images.laser, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
      } else if (item_id == 2){
        drawSprite(images.energy_cube, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
      } else if (item_id == 3){
        drawSprite(images.potion, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
      } else if (item_id == 4){
        drawSprite(images.bubble, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
      }
    }

    function drawGhost(x, y, ox, oy, direction, update) {
      const frameCols = 4; // frames per row
      const frameRows = 4; // directions
      const spriteW = 512;
      const spriteH = 512;

      const row = direction; // direction: "N": 0, "E": 1, "S": 2, "W": 3

      const sx = ghostFrameCount % frameCols * spriteW;
      if (update){
        ghostFrameCount = (ghostFrameCount + 1)%frameCols;
      }
      const sy = row * spriteH;

      const scale = 2*tile / spriteW;
      const dw = spriteW * scale;
      const dh = spriteH * scale;

      // center on tile
      const dx = ox + x * tile - (dw - tile)/2;
      const dy = oy + y * tile - (dh - tile)/2;

      drawSprite(images.ghost, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
    }

    function drawSelf(x, y, ox, oy, direction, update){
      const frameCols = 4; // frames per row
      const frameRows = 4; // directions
      const spriteW = 1024;
      const spriteH = 1024;

      const row = direction; // direction: "N": 0, "E": 1, "S": 2, "W": 3

      const sx = selfFrameCount % frameCols * spriteW;
      if (update){
        selfFrameCount = (selfFrameCount + 1)%frameCols;
      }
      const sy = row * spriteH;

      const scale = 2*tile / spriteW;
      const dw = spriteW * scale;
      const dh = spriteH * scale;

      // center on tile
      const dx = ox + x * tile - (dw - tile)/2;
      const dy = oy + y * tile - (dh - tile)/2;

      drawSprite(images.self, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
    }

    function drawOther(x, y, ox, oy, direction, update, frame) {
      const frameCols = 4; // frames per row
      const frameRows = 4; // directions
      const spriteW = 1024;
      const spriteH = 1024;

      const row = direction; // direction: "N": 0, "E": 1, "S": 2, "W": 3

      const sx = frame % frameCols * spriteW;
      const sy = row * spriteH;

      const scale = 2*tile / spriteW;
      const dw = spriteW * scale;
      const dh = spriteH * scale;

      // center on tile
      const dx = ox + x * tile - (dw - tile)/2;
      const dy = oy + y * tile - (dh - tile)/2;

      drawSprite(images.other, sx, sy, spriteW, spriteH, dx, dy, dw, dh);
    }

    let frameCount = 0;
    let ghostFrameCount = 0;
    let selfFrameCount = 0;

    function render(updateEnvironment){
      const now = performance.now();
      if (gameState === "instructions"){
        drawInstructions(now, 1);
        return;
      } else if (gameState === "transition"){
        const elapsed = now - transitionStart;
        const duration = 1000; // ms
        const t = Math.min(1, elapsed / duration);
        const alpha = 1 - t;
        drawInstructions(now, alpha);
        if (t >= 1){ 
          gameState = "playing";     
          bgMusic.play();
          stopSoundLoop();
          playSoundLoopWithRandomDelay("/assets/help_me.mp3", 40, 10);
          //startScreen.style.display = "none";
          canvas.style.display = "block";
          ghostInterval(Module.get_d());
          players[playerKey] = {
            x: Module.getX(),
            y: Module.getY(),
            floor: Module.getFloor(),
            health: Module.getHealth(),
            direction: Module.getDirection(),
            active: true,
            invincible: Module.get_invincibility()
          };
          channel.track(players[playerKey]);
          //startGame(); // initialize maze, players, ghosts, etc.
        }
        return;
      }
      // gameState = playing or gameover
      if (gameState !== "playing"){
        // gameover
        return;
      }
      ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);

      let offsetX = canvas.clientWidth / 2 - Module.getX() * tile;
      let offsetY = canvas.clientHeight / 2 - Module.getY() * tile;
      let mazeHeight = Module.getHeight();
      let mazeWidth = Module.getWidth();

      // basic render
      for (let x = 0; x < mazeHeight; x++) {
        for (let y = 0; y < mazeWidth; y++) {
          if (Module.getCell(x, y) === 'X'){ continue; }
          if (Module.getCell(x, y) == '#'){ // boundary obstacles
            drawFloor(x, y, offsetX, offsetY, 2);
          } else if (Module.getCell(x, y) == 'E'){ // exit
            if (Module.getCell(x + 1, y) === 'E' && Module.getCell(x, y + 1) === 'E'){
              drawFloor(x, y, offsetX, offsetY, 3);
            } else if (Module.getCell(x + 1, y) === 'E'){
              drawFloor(x, y, offsetX, offsetY, 5);
            } else if (Module.getCell(x, y + 1) === 'E'){
              drawFloor(x, y, offsetX, offsetY, 4);
            } else {
              drawFloor(x, y, offsetX, offsetY, 6);
            }
            //ctx.fillStyle = "green";
            //ctx.fillRect(offsetX + x*tile, offsetY + y*tile, tile, tile);
          } else {
            if ((x + y)%2 === 0){
              drawFloor(x, y, offsetX, offsetY, (x + y)%2);
            } else {
              drawFloor(x, y, offsetX, offsetY, (x + y)%2);
            }
          }
        }
      }

      const tripleMap = new Map();
      const map_key = (a, b, c) => `${a},${b},${c}`;

      // draw ghosts
      for (const [key, g] of Object.entries(ghosts)) {
        if (ghosts[key].floor !== Module.getFloor()){
          // don't draw, not on the same floor
        } else if (!ghosts[key].active){
          // don't draw, ghost not active
        } else {
          tripleMap.set(map_key(g.x, g.y, 2), Module.ghostGetDirection());
        }
      }

      // draw players
      for (const [key, p] of Object.entries(players)) {
        ctx.fillStyle = key === playerKey ? "red" : "blue";
        if (key !== playerKey && players[key].floor !== Module.getFloor()){
          // don't draw, not on the same floor
        } else if (!players[key].active){
          // don't draw, not active
        } else if (key === playerKey){ // self
          tripleMap.set(map_key(p.x, p.y, 0), Module.getDirection());
        } else {
          tripleMap.set(map_key(p.x, p.y, 1), [p.direction, p.health, p.invincible]);
        }
      }

      // draw maze
      for (let y = 0; y < mazeWidth; y++) {
        for (let x = 0; x < mazeHeight; x++){
          if (Module.getCell(x, y) === 'c'){ // chair
            drawOffice(0, x, y, offsetX, offsetY);
          }
          if (Module.getCell(x, y) === 't'){ // table
            drawOffice(1, x, y, offsetX, offsetY);
          }
          if (Module.getCell(x, y) === 'w'){ // water cooler
            drawOffice(2, x, y, offsetX, offsetY);
          }
          if (Module.getCell(x, y) === 'v'){ // vending machine
            drawOffice(3, x, y, offsetX, offsetY);
          }
          if (Module.getCell(x, y) === 'p'){ // printer
            drawOffice(4, x, y, offsetX, offsetY);
          }
        }
        for (let x = 0; x < mazeHeight; x++) {
          if (Module.getCell(x, y) === 'F') { // fire
            drawFireWall(x, y, offsetX, offsetY, frameCount);
          }
          if (Module.getCell(x, y) === 'I') { // fire extinguisher
            drawItemS(0, x, y, offsetX, offsetY, frameCount);
          }
          if (Module.getCell(x, y) == 'L'){ // laser
            drawItem(1, x, y, offsetX, offsetY);
          }
          if (Module.getCell(x, y) == 'N'){ // energy ball
            drawItemS(2, x, y, offsetX, offsetY, frameCount);
          }
          if (Module.getCell(x, y) == 'H'){ // potion
            drawItem(3, x, y, offsetX, offsetY);
          }
          if (Module.getCell(x, y) === 'B'){ // bubble
            drawItemS(4, x, y, offsetX, offsetY, frameCount);
          }
          if (Module.getCell(x, y) === 'T'){ // temporary fire
            drawSpark(x, y, offsetX, offsetY, frameCount);
          }
          if (Module.getCell(x, y) === 'i'){ // illuminated
            ctx.fillStyle = "#00FF80";
            ctx.fillRect(offsetX + x*tile, offsetY + y*tile, tile, tile);
          }
          // render players after rendering environment
          if (tripleMap.has(map_key(x, y, 1))){
            const [dir, hea, inv] = tripleMap.get(map_key(x, y, 1));
            if (hea > 0){
              drawOther(x, y, offsetX, offsetY, dir, updateEnvironment, Math.floor(Math.random() * 4));
              const { sx, sy } = worldToScreen(x, y);
              drawHealthBar(ctx, sx, sy, hea ?? 100, 100);
            }
            if (inv > 0){
              drawItemS(4, x, y, offsetX, offsetY, frameCount);
            }
          }
          if (tripleMap.has(map_key(x, y, 2))){
            drawGhost(x, y, offsetX, offsetY, tripleMap.get(map_key(x, y, 2)), updateEnvironment);
          }
          if (tripleMap.has(map_key(x, y, 0))){
            drawSelf(x, y, offsetX, offsetY, tripleMap.get(map_key(x, y, 0)), updateEnvironment);
            if (Module.get_invincibility() > 0){
              drawItemS(4, x, y, offsetX, offsetY, frameCount);
            }
            const { sx, sy } = worldToScreen(x, y);
            drawHealthBar(ctx, sx, sy, Module.getHealth() ?? 100, 100);
            if (Module.getHealth() <= 0){ endGame(); }
          }
        }
      }
      if (updateEnvironment){
        frameCount++;
      }

      // item slot
      const slotX = 10;
      const slotY = 10;
      const slotSize = 64;

      // draw slot box
      ctx.fillStyle = "white";
      ctx.fillRect(slotX, slotY, slotSize, slotSize);
      ctx.strokeStyle = "black";
      ctx.lineWidth = 2;
      ctx.strokeRect(slotX, slotY, slotSize, slotSize);
      // draw icon if player has item
      if (currentItem === "fire_extinguisher") {
        ctx.drawImage(images.fire_extinguisher, slotX + 4, slotY + 4, slotSize - 8, slotSize - 8);
      } else if (currentItem === "laser"){
        ctx.drawImage(images.laser, slotX + 4, slotY + 4, slotSize - 8, slotSize - 8);
      } else if (currentItem === "energy_cube"){
        ctx.drawImage(images.energy_cube, slotX + 4, slotY + 4, slotSize - 8, slotSize - 8);
      } else if (currentItem === "potion"){
        ctx.drawImage(images.potion, slotX + 4, slotY + 4, slotSize - 8, slotSize - 8);
      } else if (currentItem === "bubble"){
        ctx.drawImage(images.bubble, slotX + 4, slotY + 4, slotSize - 8, slotSize - 8);
      }

      ctx.font = "24px 'Pixelify Sans'";
      ctx.fillStyle = "white";
      ctx.textAlign = "right"; // align text to the right

      // draw text at top-right corner
      ctx.fillText("Level: " + Module.getFloor(), canvas.clientWidth - 10, 30);
    }



    // --- Movement -> update local + track() presence ---
    window.addEventListener("keydown", (e) => {

      if (gameState !== "playing") return;

      if (e.key === "ArrowUp" || e.key === "ArrowDown" || e.key === "ArrowLeft" || e.key === "ArrowRight"){ // movement
        let dx = 0, dy = 0;
        if (e.key === "ArrowUp"){
          dy = -1;
          Module.setDirection(3);
        }
        if (e.key === "ArrowDown"){
          dy = 1;
          Module.setDirection(2);
        }
        if (e.key === "ArrowLeft"){
          dx = -1;
          Module.setDirection(1);
        }
        if (e.key === "ArrowRight"){
          dx = 1;
          Module.setDirection(0);
        }
        if (!dx && !dy) return;

        let res = Module.movePlayer(dx, dy);
        if (res){
          playSound(levelCompleteSound);
          ghostInterval(Module.get_d());
        }
      } else if (e.key === "c"){ // pick up item
        
        const x = Module.getX();
        const y = Module.getY();
        const floor = Module.getFloor();

        let cur = Module.tryPickup(x, y, floor);

        if (cur !== -1) {
          currentItemCode = cur;
          // picked locally → broadcast to others
          playSound(getItemSound);
          if (currentItemCode === 0){
            currentItem = "fire_extinguisher";
          } else if (currentItemCode === 1){
            currentItem = "laser";
          } else if (currentItemCode === 2){
            currentItem = "energy_cube";
          } else if (currentItemCode === 3){
            currentItem = "potion";
          } else if (currentItemCode === 4){
            currentItem = "bubble"
          }
          channel.send({
            type: "broadcast",
            event: "item_picked",
            payload: { 
              messageType: 0, x, y, floor, ghost_id: 0 
            }
          });
        }
      } else if (e.key === "v"){
        if (currentItem){
          const x = Module.getX();
          const y = Module.getY();
          const floor = Module.getFloor();
          const res = Module.tryUse(currentItemCode, floor);
          if (currentItem === "fire_extinguisher"){
            if (res[0]){ // item actually has some use
              playSound(fireExtinguisherSound);
              channel.send({
                type: "broadcast",
                event: "fire_extinguished",
                payload: { 
                  messageType: 2, x: res[1][0], y: res[1][1], floor, ghost_id: 0 
                }
              });
              render(false);
            }
          } else if (currentItem === "laser"){
            // TODO illuminate path
            if (res[0]){
              channel.send({
                type: "broadcast",
                event: "illuminate",
                payload: { 
                  messageType: 3, x: res[1][0], y: res[1][1], floor, ghost_id: 0 
                }
              });
              render(false);
            }
          } else if (currentItem === "energy_cube"){
            playSound(explosionSound);
            if (res[0]){
              // check all ghosts
              let edit_own_ghost = false;
              for (const [key, g] of Object.entries(ghosts)) {
                if (ghosts[key].floor !== Module.getFloor()){
                  // don't care, not on the same floor
                } else {
                  if (Math.abs(g.x - res[1][0]) + Math.abs(g.y - res[1][1]) <= 5){ // manhattan distance of 2
                    channel.send({
                      type: "broadcast",
                      event: "ghost_eliminated",
                      payload: { 
                        messageType: 1, x: res[1][0], y: res[1][1], floor, ghost_id: key
                      }
                    });
                    if (key === playerKey && Module.ghost_is_active()){
                      edit_own_ghost = true;
                      Module.ghost_toggle_active(); // turn active off
                    }
                  }
                }
              }
              if (edit_own_ghost){
                ghosts[playerKey] = {
                  x: 0, // doesn't matter
                  y: 0, // doesn't matter
                  floor: Module.getFloor(),
                  active: Module.ghost_is_active() // presumably false
                };
              }
              render(false);
            }
          } else if (currentItem === "potion"){
            if (res[0]){
              // player's health incremented already
            }
          } else if (currentItem === "bubble"){
            if (res[0]){
              invincibility = true;
              // player gets invincibility
            }
          }
          currentItemCode = -1;
          currentItem = null;
        }

      }

      // Update my local cached presence immediately for snappy rendering
      players[playerKey] = {
        x: Module.getX(),
        y: Module.getY(),
        floor: Module.getFloor(),
        health: Module.getHealth(),
        direction: Module.getDirection(),
        active: (gameState === "playing"),
        invincible: Module.get_invincibility()
      };
      channel.track(players[playerKey]);
      render(false);
    });

    loadImages(imageSources)
    .then(loaded => {
      images = loaded;
      setInterval(() => {
        if (gameState === "gameover") return;
        render(true);
      }, 200);
    })
    .catch(err => console.error(err));

    let intervalId = null;
    function ghostInterval(p){
      const intervalDuration = 1000 / p;
      if (intervalId !== null) {
        clearInterval(intervalId);
      }

      intervalId = setInterval(() => {
        if (gameState !== "playing") return;
        Module.tick();
        let need_update = false;
        if (invincibility === true && Module.get_invincibility() == 0){
          invincibility = false;
          players[playerKey].invincible = false;
          need_update = true;
        }
        // get player positions, call moveGhost, broadcast
        const playerCoords = new Module.VectorPairIntInt();

        for (const [key, p] of Object.entries(players)) {
          if (players[key].floor !== Module.getFloor() || !players[key].active){
            // don't draw, not on the same floor or not active
          } else {
            playerCoords.push_back([p.x, p.y]);
          }
        }
        
        // only execute this logic if ghost is active
        if (Module.ghost_is_active()){
          const newGhostPos = Module.moveGhost(playerCoords);
          channel.send({
            type: "broadcast",
            event: "ghost_moved",
            payload: { ghostId: playerKey, x: newGhostPos[0], y: newGhostPos[1], floor: Module.getFloor() }
          });
          // update local ghosts cache
          ghosts[playerKey] = {
            x: newGhostPos[0],
            y: newGhostPos[1],
            floor: Module.getFloor(),
            active: Module.ghost_is_active()
          };
        }

        for (const [key, g] of Object.entries(ghosts)) {
          if (ghosts[key].floor !== Module.getFloor() || !g.active){
            // don't care, not on the same floor or not active
          } else {
            if (g.x === players[playerKey].x && g.y === players[playerKey].y){
              Module.takeDamage(30);
              if (Module.getHealth() > 0){ playSound(hurtSound); }
              for (let ii = 0; ii < 5; ii++){
                let rng = 3*Math.random();
                if (rng < 1){
                  splat(5, Math.random()*600, items, 0.2);
                } else if (rng < 2){
                  splat(Math.random()*600, 5, items, 0.2);
                } else {
                  splat(595, Math.random()*600, items, 0.2);
                }
              }
              if (!focused){
                focused = true;
                drawloop();
              } else {
                clicked = true;
                setTimeout(function (){ clicked = false; }, 100);
              }
              players[playerKey].health = Module.getHealth(); // instant update since local
              need_update = true;
            }
          }
        }

        if (need_update){ channel.track(players[playerKey]); }
      }, intervalDuration);
    }

    // Render once (in case presence sync hasn't arrived yet)
    players[playerKey] = { x: Module.getX(), y: Module.getY(), floor: Module.getFloor(), health: Module.getHealth(), direction: Module.getDirection(), active: (gameState === "playing"), invincible: Module.get_invincibility() };
    // render(false);
  </script>
</body>
</html>